% Stuff I hate about Python

Python may be my favorite language, but there sure are some things seriously
wrong with it.

(This is all Python 3.1 code, unless otherwise noted.) 

Discordianism
=============

I thought a bit about which programming language is the most Discordian one, and
it must be Python. "Python?! Python is clear and precise, how can it be
Discordian?! Shouldn't it be something like Brainfuck, or Malbolge, or PHP?" No,
those are simply evil. They are, in Discordian lingo, destructive chaos. But a
proper Discordian language must be creatively chaotic, instead. Instead of just
screwing up because of incompetence or malice, it needs to actively take apart
order to achieve something greater.

"So why not Perl, or maybe Ruby? They sure have a culture that looks very
Discordian." True, but that's exactly the problem: you can not mindfuck someone
if they are _expecting_ it. A [Bavarian Fire Drill] doesn't work if you prepare
people for it. It works only _because_ it is a completely legit action in
_absolutely the wrong context_.

And that's why you need a language that pretends to be serious and orderly, but
that can also go all Eris on your ass. Like Python. Lemme show you them:

> GP: Is Eris true?  
> M2: Everything is true.  
> GP: Even false things?  
> M2: Even false things are true.  
> GP: How can that be?  
> M2: I don't know man, I didn't do it.  
> -- [Principia Discordia]

In Python 2.x, you can do:

~~~ {.python}
True = False
# This enables us to do:
if True:
    print "All Hail Eris!"
if False:
    print "And Ewige Blumenkraft!" 
~~~

Even more fun, add a little

~~~ {.python}
True, False = False, True
~~~

to your code and enjoy the confusion and self-doubt the next maintainer will
face! (Or add it to your own code while drunk, making sure to forget about it
afterwards!)[^haskell]

[^haskell]: On the other hand, there's Haskell, which allows you to redefine
    functions in a context, so that you can have 

    ~~~ {.haskell}
    let 2 + 2 = 5
    ~~~
    
    , which is very Orwellian indeed.

Pokemon-Speak
=============

What I mean is stuff like this:

~~~ {.python}
import datetime

d = datetime.datetime(2012, 12, 21)
now = datetime.datetime.now()
dt = (d - now).days
print("Only {} days left until the end of the world!".format(dt))
~~~

Sure, I can abbreviate it, but that obfuscates the code somewhat. Related to
this is the explicit _self_. I mean, seriously? Sure, it makes it clear what you
are calling, but still, stuff like this really gets on my nerves:

~~~ {.python}
def make_website(self):
    self.make_html_files(self.src, self.dst)
    self.make_css_files(self.src, self.dst)
    self.upload(self.ftp)
~~~

Half that code is just pure noise!

Long Code is Long
=================

"There should be one - and preferably only one - obvious way to do it." leads to
some seriously overlong code sometimes. I mean, the shortest way to check
whether a file is newer than another is this:

~~~ {.python}
import datetime, os

def a_newer_than_b(a, b):
    return (datetimet.datetime.fromtimestamp(os.stat(a).st_mtime)
            > datetimet.datetime.fromtimestamp(os.stat(b).st_mtime))
~~~

This is a bad joke. In Perl, you do "if ($a -ot $b) {...}". Why can't I have
something just as simple?

Another good example is some list comprehension inconsistency. I can do:

~~~ {.python}
l = [x for x in haystack if isinstance(x, Needle)]
~~~

, but I can't do:
    
~~~ {.python}
for f in files if os.path.exists(f):
    mangle(f)
~~~

Why not?                       

[Bavarian Fire Drill]: http://s23.org/wiki/Bavarian_Fire_Drill
[Principia Discordia]: http://www.principiadiscordia.com/book/6.php
